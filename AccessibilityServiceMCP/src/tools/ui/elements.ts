/**
 * UI Elements Tools
 */
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { apiClient } from "../../api/client.js";

export function registerUiElementsTools(server: McpServer) {
  server.tool(
    "find_elements",
    "üéØ TOOL CH√çNH - AI s·∫Ω ∆∞u ti√™n s·ª≠ d·ª•ng tool n√†y ƒë·ªÉ t√¨m ki·∫øm UI elements tr∆∞·ªõc khi th·ª±c hi·ªán b·∫•t k·ª≥ action n√†o. C√≥ smart fallback system tr·∫£ v·ªÅ elements ph√π h·ª£p khi kh√¥ng t√¨m th·∫•y ch√≠nh x√°c",
    {
      text: z.string().optional().describe("Text c·∫ßn t√¨m"),
      contentDescription: z
        .string()
        .optional()
        .describe("Content description c·∫ßn t√¨m"),
      className: z.string().optional().describe("Class name c·∫ßn t√¨m"),
      actionType: z
        .enum(["click", "input", "scroll", "check", "read"])
        .optional()
        .describe("Lo·∫°i action mu·ªën th·ª±c hi·ªán ƒë·ªÉ quy·∫øt ƒë·ªãnh fallback type"),
    },
    async ({ text, contentDescription, className, actionType }) => {
      try {
        const result = await apiClient.findElements({
          text,
          contentDescription,
          className,
          actionType,
        });

        let responseText = "";

        if (result.count > 0) {
          responseText = `‚úÖ **T√¨m th·∫•y ${result.count} elements**\n\n`;
          result.elements.forEach((element, index) => {
            responseText += `**Element ${index + 1}:**\n`;
            responseText += `- Text: ${element.text || "N/A"}\n`;
            responseText += `- Description: ${
              element.contentDescription || "N/A"
            }\n`;
            responseText += `- Class: ${element.className || "N/A"}\n`;
            responseText += `- Bounds: (${element.bounds.left},${element.bounds.top}) to (${element.bounds.right},${element.bounds.bottom})\n`;
            responseText += `- Center: (${element.bounds.centerX},${element.bounds.centerY})\n`;
            responseText += `- Clickable: ${element.isClickable}\n`;
            responseText += `- Editable: ${element.isEditable}\n\n`;
          });
        } else if (result.fallback) {
          responseText = `üîÑ **Fallback Mode** (${result.fallbackType})\n\n`;
          responseText += `${result.message}\n\n`;

          if (result.clickableElements && result.clickableElements.length > 0) {
            responseText += `üñ±Ô∏è **Clickable Elements (${result.totalClickable}):**\n`;
            result.clickableElements.slice(0, 5).forEach((element, index) => {
              responseText += `${index + 1}. ${
                element.contentDescription || element.text || element.className
              } `;
              responseText += `at (${element.bounds.centerX},${element.bounds.centerY})\n`;
            });
            if (result.clickableElements.length > 5) {
              responseText += `... v√† ${
                result.clickableElements.length - 5
              } elements kh√°c\n`;
            }
            responseText += "\n";
          }

          if (result.editableElements && result.editableElements.length > 0) {
            responseText += `‚úèÔ∏è **Editable Elements (${result.totalEditable}):**\n`;
            result.editableElements.forEach((element, index) => {
              responseText += `${index + 1}. ${
                element.contentDescription || element.text || element.className
              } `;
              responseText += `at (${element.bounds.centerX},${element.bounds.centerY})\n`;
            });
            responseText += "\n";
          }

          if (
            result.scrollableElements &&
            result.scrollableElements.length > 0
          ) {
            responseText += `üìú **Scrollable Elements (${result.totalScrollable}):**\n`;
            result.scrollableElements.forEach((element, index) => {
              responseText += `${index + 1}. ${element.className} `;
              responseText += `at (${element.bounds.centerX},${element.bounds.centerY})\n`;
            });
            responseText += "\n";
          }
        } else {
          responseText = "‚ùå **Kh√¥ng t√¨m th·∫•y elements n√†o**";
        }

        return {
          content: [
            {
              type: "text",
              text: responseText,
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå **L·ªói:** ${
                error instanceof Error ? error.message : String(error)
              }`,
            },
          ],
        };
      }
    }
  );

  server.tool(
    "get_ui_tree",
    "L·∫•y c√¢y UI ƒë·∫ßy ƒë·ªß c·ªßa m√†n h√¨nh hi·ªán t·∫°i - CH·ªà d√πng khi get_ui_tree_compact kh√¥ng ƒë·ªß th√¥ng tin chi ti·∫øt. ∆Øu ti√™n d√πng get_ui_tree_compact tr∆∞·ªõc",
    {},
    async () => {
      try {
        const uiTree = await apiClient.getUiTree();
        return {
          content: [
            {
              type: "text",
              text:
                `üì± **UI Tree**\n\n` +
                `- Total nodes: ${uiTree.totalNodes}\n` +
                `- Capture time: ${new Date(
                  uiTree.captureTime
                ).toLocaleString()}\n\n` +
                `**Root Node:**\n` +
                `${JSON.stringify(uiTree.rootNode, null, 2)}`,
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå **L·ªói:** ${
                error instanceof Error ? error.message : String(error)
              }`,
            },
          ],
        };
      }
    }
  );

  server.tool(
    "get_ui_tree_compact",
    "üéØ KHUY·∫æN KH√çCH - L·∫•y UI tree g·ªçn v·ªõi th√¥ng tin ƒë·∫ßy ƒë·ªß cho AI - S·ª¨ D·ª§NG KHI m·ªõi v√†o app/m√†n h√¨nh ƒë·ªÉ hi·ªÉu context v√† c√≥ g√¨ ƒë·ªÉ t∆∞∆°ng t√°c",
    {},
    async () => {
      try {
        const compactTree = await apiClient.getUiTreeCompact();

        let responseText = `üì± **UI Tree Compact**\n\n`;
        responseText += `üìä **T·ªïng quan:**\n`;
        responseText += `- Total nodes: ${compactTree.summary.totalNodes}\n`;
        responseText += `- Clickable: ${compactTree.summary.clickableCount}\n`;
        responseText += `- Editable: ${compactTree.summary.editableCount}\n`;
        responseText += `- Scrollable: ${compactTree.summary.scrollableCount}\n`;
        responseText += `- Text: ${compactTree.summary.textCount}\n\n`;

        if (compactTree.clickableElements.length > 0) {
          responseText += `üñ±Ô∏è **Clickable Elements:**\n`;
          compactTree.clickableElements
            .slice(0, 10)
            .forEach((element: any, index: number) => {
              responseText += `${index + 1}. ${
                element.text || element.contentDescription || element.className
              } `;
              responseText += `at (${element.bounds.centerX},${element.bounds.centerY})\n`;
            });
          if (compactTree.clickableElements.length > 10) {
            responseText += `... v√† ${
              compactTree.clickableElements.length - 10
            } elements kh√°c\n`;
          }
          responseText += "\n";
        }

        if (compactTree.editableElements.length > 0) {
          responseText += `‚úèÔ∏è **Editable Elements:**\n`;
          compactTree.editableElements.forEach(
            (element: any, index: number) => {
              responseText += `${index + 1}. ${
                element.text || element.contentDescription || element.className
              } `;
              responseText += `at (${element.bounds.centerX},${element.bounds.centerY})\n`;
            }
          );
          responseText += "\n";
        }

        if (compactTree.structure.length > 0) {
          responseText += `üèóÔ∏è **UI Structure:**\n`;
          compactTree.structure.slice(0, 15).forEach((node: any) => {
            const indent = "  ".repeat(node.level);
            responseText += `${indent}- ${node.type}: ${node.label} (${node.bounds})\n`;
          });
          responseText += "\n";
        }

        return {
          content: [
            {
              type: "text",
              text: responseText,
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `‚ùå **L·ªói:** ${
                error instanceof Error ? error.message : String(error)
              }`,
            },
          ],
        };
      }
    }
  );
}
